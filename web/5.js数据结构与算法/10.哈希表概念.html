<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>10.哈希表</title>
    <!-- 1.可以提供非常快速的插入-删除-查找操作 -->
    <!-- 2.比树还快 编码比树容易-->
    <!-- 不足：1.数据没有顺序 所以不能以固定的方式遍历（从小到大） -->
    <!-- 2.key不允许重复  -->

    <!-- 哈希化：将大数字转化为数组范围内下标的过程，我们就称之为哈希化 -->
    <!-- 哈希函数：通常会将单词转化为""大数字""，大数字在进行哈希化的"代码"实现放在一个函数中，这个函数我们称为哈希函数 -->
    <!-- 哈希表：最终将数据插入到这个数组，对整个结构的封装，我们就称之为是一个哈希表 -->

    <!-- 哈希化:把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中 -->

    <!-- 但是还需要解决哈希化的下标值依然会重复 如何解决这种重复?-->
    <!-- 1.链地址法  2.开放地址法 -->

    <!-- 1.链地址法：每个数组单元中存储的不再是单个数据而是一个链条 （这个链条通常是数组或者链表）-->
    <!-- 如果是链表：也就是每个数组单元中存储着一个链表 一旦发现重复 就将重复的元素插到当前重复的链表的首端或者末端 -->
    <!-- 当查询时，先根据哈希化后的下标值找到对应的位置 再取出链表依次查询寻找的数据 -->
    <!-- 因为哈希化的index找出这个数组或者链表时,通常会用到线性查找,所以数组和链表效率差不多 -->

    <!-- 2.开放地址法 -->
    <!-- 寻找空白的位置来设置冲突的数据项 -->

    <!-- ① 线性探测:线性查找空白的单元格 -->
    <!-- 如果插入的是32 哈希化之后index=2 但是2已经有了82 怎么办呢 线性探测就是从index+1开始查找和32一样的 查到空位置立即停止 -->
    <!-- 注意:在删除一个数据项时不可以把它的下标值设为null 因为会影响我们之后查询其他操作,但是可以设置为-1 这样可以继续查询 -->

    <!-- 线性探测的问题: -->
    <!-- 比如我在没有任何数据的时候插入 22 23 24 25 26 27 那么意味着 2 3 4 5 6 7下标都有元素 -->
    <!-- 这种一连串填充单元就叫做聚焦 会影响哈希表的性能 无论插入查询删除  比如插入32 连续的单元都不允许我们放置 -->

    <!-- ② 二次探测可以解决:聚焦问题 -->
    <!-- 二次探测主要优化探测时的步长   线性探测可以看作步长为1的探测 比如下标值从x开始 那么线性测试就是x+1 ,x+2 ,x+3 -->
    <!-- 二次探测 对步长做了优化 比如从下标x开始 x+1² x+2² x+3² -->
    <!-- 这样可以一次探测较长的距离 避免聚焦带来的影响 -->

    <!-- 二次探测的问题: -->
    <!-- 比如连续插入的是 32 112 82 2 192 那么它们累加的时候步长是相同的 比如从下标x开始 x+1² x+2² x+3² -->
    <!-- 会造成步长不一的一种聚焦 会影响效率 -->
    <!-- 让每个人步长不一样就可以解决 -->

    <!-- ③ 再哈希法: 为了消除线性探测和二次探测中无论步长+1 还是步长+平方 中存在的问题-->
    <!-- 二次检测的算法产生的探测序列步长是固定的 1 4 9 16 以此类推 -->
    <!-- 现在需要一种方法 产生一种依赖关键字的探测序列 而不是每个关键字都一样 -->
    <!-- 不同关键字即使映射到相同数组的下标 也可以使用不同的探测序列 -->
    <!-- 再哈希法的做法:把关键字用另外一个哈希函数再做一次哈希化 用这次哈希化的结果作为步长 -->
    <!-- 对于指定的关键字,步长在整个探测中是不变的,不给不同的关键字使用不同的步长 -->

    <!-- 特点:和第一个哈希函数不同(不要再使用上一次的哈希函数了 不然结果还是原来的位置) -->
    <!-- 不能输出为0 -->
    <!-- stepSize = constant - (key % constant) -->
    <!-- 其中constant是质数 且小于数组的容量 -->
    <!-- 例如stepSize= 5 - (key % 5)满足需求且结果不可能为0 -->

    <!-- 总结: -->
    <!-- 哈希表中执行插入和搜索效率是非常高的 -->
    <!-- 1.如果没有发生冲突 那么效率会更高 -->
    <!-- 2.如果发生冲突 存取时间就依赖后来的探测长度 -->
    <!-- 3.平均探测长度以及平均存取时间 取决于""装填因子""" 越大 探测长度越长 -->
    <!-- 4.随着装填因子变大效率下降的情况 在不同开放地址法方案中比链地址法更严重 -->

    <!-- 装填因子: -->
    <!-- 1.装填因子表示当前哈希表中""已经包含的数据项""和""整个哈希表长度""的比值 -->
    <!-- 2.装填因子 = 总数据项 / 哈希表长度 -->
    <!-- 3.开放地址法的装填因子最大是 "1" 因为它必须找到空白单元才能填入 -->
    <!-- 4.链地址法的装填因子 可以大于'1' 因为拉链法可以无限的延申下去 -->

    <!-- 霍纳法则(秦九昭算法):减少乘的次数 优化 -->
    <!-- 乘法N次 加法N次 时间复杂度从o(n²)变成了o(n) -->

    <!-- ""再哈希表""的长度最好使用质数 -->
    <!-- 1.假设表的容量不是质数 例如:表长为15(下标值0~14) -->
    <!-- 2.有个特定关键字映射到0 步长为5 探测序列是多少? -->
    <!-- 0 - 5 - 10 - 0 - 5 - 10这样类推循环下去 -->
    <!-- 算法只尝试着3个单元 如果这三个单元已经有了数据 那么会一直循环直到程序崩溃 -->
    <!-- 但是如果容量是一个质数 比如13 探测序列是多少呢 -->
    <!--  0 - 5 - 10 - 2 - 7 - 12 - 4 - 9 - 1 - 6 - 11 -3一直下去 -->
    <!-- 不仅不会产生循环 而且可以让数据在哈希表中更加均匀的分布 -->
</head>

<body>
    <script>
    </script>
</body>

</html>